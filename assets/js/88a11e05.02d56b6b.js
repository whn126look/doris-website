"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([["223710"],{131244:function(e,t,n){n.r(t),n.d(t,{metadata:()=>i,contentTitle:()=>l,default:()=>h,assets:()=>s,toc:()=>d,frontMatter:()=>r});var i=JSON.parse('{"id":"data-operate/delete/delete-overview","title":"Delete Overview","description":"\x3c!--","source":"@site/docs/data-operate/delete/delete-overview.md","sourceDirName":"data-operate/delete","slug":"/data-operate/delete/delete-overview","permalink":"/docs/dev/data-operate/delete/delete-overview","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Delete Overview","language":"en"},"sidebar":"docs","previous":{"title":"Concurrency Control for Updates in the Primary Key Model","permalink":"/docs/dev/data-operate/update/unique-update-concurrent-control"},"next":{"title":"Deleting Data with DELETE Command","permalink":"/docs/dev/data-operate/delete/delete-manual"}}'),a=n("785893"),o=n("250065");let r={title:"Delete Overview",language:"en"},l=void 0,s={},d=[{value:"Implementation Mechanism of Deletion",id:"implementation-mechanism-of-deletion",level:2},{value:"Use Cases for Delete Operations",id:"use-cases-for-delete-operations",level:2},{value:"Conditional Deletion",id:"conditional-deletion",level:3},{value:"Batch Deletion via data loading",id:"batch-deletion-via-data-loading",level:3},{value:"Deleting All Data",id:"deleting-all-data",level:3},{value:"Atomic Overwrite Using Temporary Partitions",id:"atomic-overwrite-using-temporary-partitions",level:3},{value:"Notes",id:"notes",level:2}];function c(e){let t={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"In Apache Doris, the delete operation is a key feature for managing and cleaning data to meet the flexibility needs of users in large-scale data analysis scenarios. Doris's deletion mechanism supports efficient logical deletion and multi-version data management, achieving a good balance between performance and flexibility."}),"\n",(0,a.jsx)(t.h2,{id:"implementation-mechanism-of-deletion",children:"Implementation Mechanism of Deletion"}),"\n",(0,a.jsxs)(t.p,{children:["Doris's delete operation uses ",(0,a.jsx)(t.strong,{children:"logical deletion"})," rather than directly physically deleting data. The core implementation mechanisms are as follows:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Logical Deletion"}),". The delete operation does not directly remove data from storage but adds a delete marker to the target data. There are two main ways to implement logical deletion: delete predicate and delete sign."]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"Delete predicate is used for Duplicate and Aggregate models. Each deletion directly records a conditional predicate on the corresponding dataset to filter out the deleted data during queries."}),"\n",(0,a.jsxs)(t.li,{children:["Delete sign is used for the Unique Key model. Each deletion writes a new batch of data to overwrite the data to be deleted, and the hidden column ",(0,a.jsx)(t.code,{children:"__DORIS_VERSION_COL__"})," of the new data is set to 1, indicating that the data has been deleted."]}),"\n",(0,a.jsx)(t.li,{children:'Performance comparison: The operation speed of "delete predicate" is very fast, whether deleting 1 row or 100 million rows, the speed is almost the same, it just write a conditional predicate to the dataset; the write speed of delete sign is proportional to the amount of data.'}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Multi-Version Data Management"}),". Doris supports multi-version data (MVCC, Multi-Version Concurrency Control), allowing concurrent operations on the same dataset without affecting query results. The delete operation creates a new version containing the delete marker, while the old version data is still retained."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Physical Deletion (Compaction)"}),". The periodically executed compaction process cleans up data marked for deletion, thereby freeing up storage space. This process is automatically completed by the system without user intervention. Note that only Base Compaction will physically delete data, while Cumulative Compaction only merges and reorders data, reducing the number of rowsets and segments."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"use-cases-for-delete-operations",children:"Use Cases for Delete Operations"}),"\n",(0,a.jsx)(t.p,{children:"Doris provides various deletion methods to meet different needs:"}),"\n",(0,a.jsx)(t.h3,{id:"conditional-deletion",children:"Conditional Deletion"}),"\n",(0,a.jsx)(t.p,{children:"Users can delete rows that meet specified conditions. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"DELETE FROM table_name WHERE condition;\n"})}),"\n",(0,a.jsx)(t.h3,{id:"batch-deletion-via-data-loading",children:"Batch Deletion via data loading"}),"\n",(0,a.jsx)(t.p,{children:"During data loading, logical deletion can be achieved by overwriting. This method is suitable for batch deletion of a large number of keys or synchronizing TP database deletions during CDC binlog synchronization."}),"\n",(0,a.jsx)(t.h3,{id:"deleting-all-data",children:"Deleting All Data"}),"\n",(0,a.jsx)(t.p,{children:"In some cases, data can be deleted by directly truncating the table or partition. For example:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",children:"TRUNCATE TABLE table_name;\n"})}),"\n",(0,a.jsx)(t.h3,{id:"atomic-overwrite-using-temporary-partitions",children:"Atomic Overwrite Using Temporary Partitions"}),"\n",(0,a.jsx)(t.p,{children:"In some cases, users may want to rewrite the data of a partition. If the data is deleted and then imported, there will be a period when the data is unavailable. In this case, users can create a corresponding temporary partition, import the new data into the temporary partition, and then replace the original partition atomically to achieve the goal."}),"\n",(0,a.jsx)(t.h2,{id:"notes",children:"Notes"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"The delete operation generates new data versions, so frequent deletions may increase the number of versions, affecting query performance."}),"\n",(0,a.jsx)(t.li,{children:"Compaction is a key step in freeing up storage space. Users are advised to adjust the compaction strategy based on system load."}),"\n",(0,a.jsx)(t.li,{children:"Deleted data will still occupy storage until compaction is completed, so the delete operation itself will not immediately reduce storage usage."}),"\n"]})]})}function h(e={}){let{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},250065:function(e,t,n){n.d(t,{Z:function(){return l},a:function(){return r}});var i=n(667294);let a={},o=i.createContext(a);function r(e){let t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);